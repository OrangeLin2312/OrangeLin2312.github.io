<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20241113154244223.png" alt="image-20241113154244223"></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>类在jvm中加载时执行，只执行一次。</p><p>“静态代码块只执行一次”的意思是，在Java程序运行期间，当一个类被加载到Java虚拟机（JVM）时，与该类关联的静态代码块会被自动执行，而且这个执行过程只发生一次。</p><p>这里有几个关键点需要理解：</p><ol><li><strong>类加载</strong>：当程序首次引用一个类（例如，通过创建该类的实例，访问该类的静态方法或静态字段等），JVM会检查该类是否已经被加载。如果没有，JVM会加载该类，包括执行其静态初始化代码（即静态代码块）。</li><li><strong>静态代码块的执行</strong>：静态代码块在类加载过程中执行，而不是在创建类的实例时执行。这意味着，无论创建多少个类的实例，静态代码块都只会执行一次。</li><li><strong>只执行一次</strong>：静态代码块的执行与类的实例化无关。一旦类被加载，静态代码块就执行了，后续对类的任何引用（包括创建更多实例）都不会再次触发静态代码块的执行。</li></ol><p>这种特性使得静态代码块非常适合用于执行只需要进行一次的初始化操作，例如创建单例对象、初始化静态资源或设置全局配置等。</p><p>下面是一个简单的例子来说明这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Example</span> <span class="variable">example1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        <span class="type">Example</span> <span class="variable">example2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当你运行<code>main</code>方法时，输出将会是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态代码块执行</span><br><span class="line">main方法开始</span><br><span class="line">main方法结束</span><br></pre></td></tr></table></figure><p>尽管在<code>main</code>方法中创建了两个<code>Example</code>类的实例，但静态代码块只执行了一次。</p><h3 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h3><p><strong>非静态代码块（也称为实例初始化块）是在创建类的实例时执行的代码块，它不是在类加载时执行，而是在每次创建对象时都会执行</strong>。非静态代码块通常用于执行一些通用的实例初始化操作，这些操作对于类的所有实例都是相同的。</p><p>非静态代码块的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非静态代码块在每次创建类的实例时都会执行，并且在构造函数之前执行。如果有多个非静态代码块，它们将按照在类中出现的顺序依次执行。</p><p>下面是一个简单的例子来说明非静态代码块的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="comment">// 非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Example</span> <span class="variable">example1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        <span class="type">Example</span> <span class="variable">example2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当你运行<code>main</code>方法时，输出将会是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main方法开始</span><br><span class="line">非静态代码块执行</span><br><span class="line">构造函数执行</span><br><span class="line">非静态代码块执行</span><br><span class="line">构造函数执行</span><br><span class="line">main方法结束</span><br></pre></td></tr></table></figure><p>可以看到，每次创建<code>Example</code>类的实例时，非静态代码块都会执行，并且在构造函数之前执行。因此，对于<code>example1</code>和<code>example2</code>两个实例，非静态代码块都分别执行了一次。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>在Java中，<code>static</code>关键字用于定义类级别的成员，这些成员不属于类的任何特定实例，而是属于整个类。静态代码块（也称为静态初始化器）是使用<code>static</code>关键字声明的代码块，它在类被加载到JVM（Java虚拟机）时执行，并且只执行一次。</p><p>静态代码块通常用于初始化静态变量或执行一些只需要在类加载时执行一次的操作。它的基本语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代码块</span></span><br><span class="line">        <span class="comment">// 初始化静态变量或执行其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你提供的代码片段中，静态代码块用于创建一个<code>Singleton</code>类的实例，并将其赋值给静态变量<code>instance</code>。这是一种常见的单例模式实现方式，称为“饿汉式”单例模式。以下是完整的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，在类加载时执行，创建Singleton实例</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共的静态方法获取Singleton实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当<code>Singleton</code>类被加载到JVM时，静态代码块会自动执行，并创建一个<code>Singleton</code>实例。之后，通过调用<code>getInstance()</code>方法，可以获取这个已经创建的实例。由于静态代码块只执行一次，因此<code>Singleton</code>类也只会创建一个实例，从而实现了单例模式。</p><p>需要注意的是，这种“饿汉式”单例模式在类加载时就创建了实例，可能会造成资源浪费，如果实例的创建需要消耗大量资源或者实例的创建依赖于某些配置信息，那么可以考虑使用“懒汉式”单例模式，在第一次使用时再创建实例。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式：内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式1：线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂：把耦合逻辑抽象出来不影响业务代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">CreateCoffee</span><span class="params">(String coffeeType)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (coffeeType.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">ACoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coffeeType.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">BCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有您需要的咖啡种类！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂：把耦合逻辑抽象出来不影响业务代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">CreateCoffee</span><span class="params">(String coffeeType)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (coffeeType.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">ACoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coffeeType.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">BCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有您需要的咖啡种类！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><strong>只考虑生产同级别的产品（如下面这个例子只生产咖啡！）</strong></p><p>对多态性的完美应用。</p><p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20241113145642446.png" alt="image-20241113145642446"></p><p>工厂也抽象出一个工厂接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂抽象接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后咖啡分类继承出不同的咖啡工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承工厂接口，专门生成A咖啡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ACoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ACoffee</span>();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咖啡店实现类写入工厂接口的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡店负责创造实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory coffeeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCoffeeFactory</span><span class="params">(CoffeeFactory coffeeFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coffeeFactory = coffeeFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">OrderCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="built_in">this</span>.coffeeFactory.createCoffee();</span><br><span class="line">        coffee.addMike();</span><br><span class="line">        coffee.addSugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>多级别产品的生产，不只咖啡。</p><p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20241113150311054.png" alt="image-20241113150311054"></p><h3 id="简单工厂-配置文件"><a href="#简单工厂-配置文件" class="headerlink" title="简单工厂+配置文件"></a>简单工厂+配置文件</h3><p>通过配置文件来进行工厂类的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Coffee&gt; coffeeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Coffee&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载类的时候加载配置文件，只加载一次（所有使用静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//创建配置文件对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prop.load(is);</span><br><span class="line">            <span class="comment">//获取map中的所有key成为一个set</span></span><br><span class="line">            Set&lt;Object&gt; keySet = prop.keySet();</span><br><span class="line">            <span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">                <span class="comment">//获取类名(引用路径</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> prop.getProperty(key.toString());</span><br><span class="line">                <span class="comment">//通过反射创建类</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);<span class="comment">//获取反射对象</span></span><br><span class="line">                <span class="type">Coffee</span> <span class="variable">o</span> <span class="operator">=</span> (Coffee) clazz.newInstance();</span><br><span class="line">                coffeeMap.put((String) key, o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">CreateCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffeeMap.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置文件，等于左边与传入type一致</span></span><br><span class="line">A=com.patterns.factory_config.ACoffee</span><br><span class="line">B=com.patterns.factory_config.BCoffee</span><br></pre></td></tr></table></figure><h4 id="注意：反射"><a href="#注意：反射" class="headerlink" title="注意：反射"></a>注意：反射</h4><p>这行代码的作用是从类路径（classpath）中加载名为 <code>bean.properties</code> 的资源文件，并将其包装在一个 <code>InputStream</code> 对象中。以下是对这行代码的详细解释：</p><p><strong>代码解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li><p>**<code>CoffeeFactory.class</code>**：</p><ul><li>获取 <code>CoffeeFactory</code> 类的 <code>Class</code> 对象。</li></ul></li><li><p>**<code>.getClassLoader()</code>**：</p><ul><li>调用 <code>Class</code> 对象的 <code>getClassLoader()</code> 方法，获取加载该类的类加载器（<code>ClassLoader</code>）。</li></ul></li><li><p>**<code>.getResourceAsStream(&quot;bean.properties&quot;)</code>**：</p><ul><li>调用类加载器的 <code>getResourceAsStream(String name)</code> 方法，传入资源文件的名称 <code>&quot;bean.properties&quot;</code>。</li><li><code>getResourceAsStream</code> 方法会在类路径（classpath）中查找指定的资源文件，并返回一个 <code>InputStream</code> 对象，如果找不到该资源文件，则返回 <code>null</code>。</li></ul></li></ol><p><strong>类路径（classpath）</strong></p><p>类路径是 Java 虚拟机（JVM）用于查找类文件和资源文件的路径集合。它可以包含以下几种类型的路径：</p><ul><li>编译后的 <code>.class</code> 文件所在的目录。</li><li>JAR 文件中的类和资源。</li><li>通过 <code>-classpath</code> 或 <code>-cp</code> 命令行选项指定的路径。</li></ul><p><strong>资源文件的加载</strong></p><p>在 Java 应用程序中，资源文件通常放在类路径下的某个目录中，例如 <code>src/main/resources</code> 目录（对于 Maven 项目）。通过 <code>getResourceAsStream</code> 方法，可以方便地从类路径中加载这些资源文件。</p><p><strong>示例</strong></p><p>假设你的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└── main</span><br><span class="line">    └── resources</span><br><span class="line">        └── bean.properties</span><br></pre></td></tr></table></figure><p>并且你在代码中使用上述行来加载 <code>bean.properties</code> 文件，那么 JVM 会在类路径中查找该文件，并将其包装在一个 <code>InputStream</code> 对象中。</p><p><strong>使用示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Resource not found: bean.properties&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 properties 对象</span></span><br><span class="line">            System.out.println(properties.getProperty(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>getResourceAsStream</code> 方法加载 <code>bean.properties</code> 文件，并将其内容读取到一个 <code>Properties</code> 对象中，然后输出某个属性的值。</p><p>通过这种方式，可以方便地在 Java 应用程序中加载和使用资源文件。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><p>代理类是在内存中动态生成的，我们看不到的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理jdk</span></span><br><span class="line"><span class="comment"> * 获取代理对象的工厂类</span></span><br><span class="line"><span class="comment"> * jdk提供了proxy代理对象</span></span><br><span class="line"><span class="comment"> * 代理对象也继承了对应接口（SellTickets）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">trainStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Proxy.newProxyInstance(形参如下)</span></span><br><span class="line"><span class="comment">         * ClassLoader loader:类加载器，用于加载代理类，可以通过类目标对象获取类加载器</span></span><br><span class="line"><span class="comment">         *  Class&lt;?&gt;[] interfaces：代理类和目标对象都实现的接口的字节码对象</span></span><br><span class="line"><span class="comment">         *  InvocationHandler h：代理对象调用的处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">                trainStation.getClass().getClassLoader(),</span><br><span class="line">                trainStation.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy 被调用方法的代理实例(就是proxyObject一般不使用</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method 对应于在代理实例上调用的接口方法的 &#123;<span class="doctag">@code</span> Method&#125; 实例。</span></span><br><span class="line"><span class="comment">                     * 该 &#123;<span class="doctag">@code</span> Method&#125; 对象的声明类将是方法声明所在的接口，</span></span><br><span class="line"><span class="comment">                     * 这可能是代理接口继承该方法通过的超接口。</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args 包含在代理实例上的方法调用中传递的参数值的对象数组，</span></span><br><span class="line"><span class="comment">                     * 或者如果接口方法不接受参数，则为 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment">                     * 原始类型的参数被包装在适当的原始包装器类的实例中，</span></span><br><span class="line"><span class="comment">                     * 例如 &#123;<span class="doctag">@code</span> java.lang.Integer&#125; 或 &#123;<span class="doctag">@code</span> java.lang.Boolean&#125;。</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;收取代理费用100元！（jdk动态代理）&quot;</span>);</span><br><span class="line">                        <span class="comment">//使用反射调用method对象</span></span><br><span class="line">                        <span class="comment">//这个意思就是调用了目标对象中的method方法了（如sell，当然别的也行，obj就是返回值</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> method.invoke(trainStation, args);</span><br><span class="line">                        <span class="keyword">return</span> object;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxyObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式区别"><a href="#代理模式区别" class="headerlink" title="代理模式区别:"></a>代理模式区别:</h3><p>静态代理：如果有新的方法需要添加，那么接口、目标对象、代理对象就都要新增方法，而动态代理就不用在代理对象中再新增，因为我们使用了代理工厂对代理对象进行动态代理。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/15/%E5%89%8D%E7%AB%AFvue/"/>
      <url>/2024/11/15/%E5%89%8D%E7%AB%AFvue/</url>
      
        <content type="html"><![CDATA[<h1 id="前端学习-Vue"><a href="#前端学习-Vue" class="headerlink" title="前端学习-Vue"></a>前端学习-Vue</h1><h2 id="vue中，父组件给子组件传值，子组件给父组件传值，怎么传，请举例说明"><a href="#vue中，父组件给子组件传值，子组件给父组件传值，怎么传，请举例说明" class="headerlink" title="vue中，父组件给子组件传值，子组件给父组件传值，怎么传，请举例说明"></a>vue中，父组件给子组件传值，子组件给父组件传值，怎么传，请举例说明</h2><p>在Vue中，父组件向子组件传递数据通常使用<code>props</code>，而子组件向父组件传递数据则使用自定义事件(<code>$emit</code>)。下面我将通过一个简单的例子来说明这两个过程。</p><p>如果你在使用Vue 3的<code>setup</code>语法糖的同时，还想保持选项式API的风格，你可以这样做：</p><h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p><strong>父组件 (<code>ParentComponent.vue</code>):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line">    &lt;ChildComponent :message=&quot;parentMessage&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import ChildComponent from &#x27;./ChildComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">const parentMessage = ref(&#x27;来自父组件的消息&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件 (<code>ChildComponent.vue</code>):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;子组件&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; defineProps &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  message: String</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><p><strong>子组件 (<code>ChildComponent.vue</code>):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;子组件&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;sendMessageToParent&quot;&gt;发送消息给父组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; defineEmits &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const emit = defineEmits([&#x27;child-event&#x27;]);</span><br><span class="line"></span><br><span class="line">function sendMessageToParent() &#123;</span><br><span class="line">  emit(&#x27;child-event&#x27;, &#x27;来自子组件的消息&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>父组件 (<code>ParentComponent.vue</code>):</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line">    &lt;ChildComponent @child-event=&quot;handleChildEvent&quot; /&gt;</span><br><span class="line">    &lt;p&gt;从子组件接收到的消息: &#123;&#123; childMessage &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import ChildComponent from &#x27;./ChildComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">const childMessage = ref(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">function handleChildEvent(message) &#123;</span><br><span class="line">  childMessage.value = message;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了<code>&lt;script setup&gt;</code>语法糖，这是Vue 3中推荐的一种更简洁的组件编写方式。在<code>&lt;script setup&gt;</code>中，我们可以直接使用<code>ref</code>来定义响应式数据，使用<code>defineProps</code>来定义组件的<code>props</code>，以及使用<code>defineEmits</code>来定义组件可以触发的事件。</p><p>这种方式结合了组合式API的简洁性和选项式API的风格，使得代码更加清晰和易于维护。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/15/SSM%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/11/15/SSM%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-SSM初步学习"><a href="#title-SSM初步学习" class="headerlink" title="title:SSM初步学习"></a>title:SSM初步学习</h2><h1 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h1><h2 id="spring核心容器"><a href="#spring核心容器" class="headerlink" title="spring核心容器"></a>spring核心容器</h2><p>容器</p><p>bean</p><p>依赖注入</p><h3 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h3><p>使用对象：从主动new对象变成了<strong>外部提供</strong>，由IOC容器（外部）负责管理对象，被管理的对象叫做Bean。</p><p>DI：依赖注入，绑定两个对象之间的关系。</p><p>bean创建出来默认是单例模式，因此封装的model对象其实是不适合交给容器管理的。</p><h4 id="实例化bean的三种方式"><a href="#实例化bean的三种方式" class="headerlink" title="实例化bean的三种方式"></a>实例化bean的三种方式</h4><ol><li><p>通过构造方式（反射）</p></li><li><p>静态工厂（了解即可</p></li><li><p>实例化工厂</p></li><li><p>（重）FactoryBean接口</p></li><li><pre><code class="java">public class UserDaoFactory implements FactoryBean&lt;UserDao&gt; &#123;    @Override    public UserDao getObject() throws Exception &#123;        return new UserDaoImpl();    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return UserDao.class;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 依赖注入的方式</span><br><span class="line"></span><br><span class="line">1. setter注入</span><br><span class="line">2. 构造器注入</span><br><span class="line">3. 自动装配（自动找寻set入口装配，所以set入口不能省略</span><br><span class="line">   - 按类型</span><br><span class="line">   - 按名称（不需要</span><br><span class="line"></span><br><span class="line">自动装配的优先级要小于setter和构造器</span><br><span class="line"></span><br><span class="line">### 核心容器总结</span><br><span class="line"></span><br><span class="line">#### 容器相关</span><br><span class="line"></span><br><span class="line">BeanFactory是IOC容器的顶层接口，是bean的延迟加载</span><br><span class="line"></span><br><span class="line">ApplicationContext是ioc的核心接口，是bean的立即加载</span><br><span class="line"></span><br><span class="line">![image-20241114210710832](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20241114210710832.png)</span><br><span class="line"></span><br><span class="line"> ![image-20241114210845222](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20241114210845222.png)</span><br><span class="line"></span><br><span class="line">## 注解开发</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//创建新的命名空间context，需要包扫描</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=</span><br><span class="line">               &quot;http://www.springframework.org/schema/beans</span><br><span class="line">                http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                http://www.springframework.org/schema/context</span><br><span class="line">                http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!--    1.先创建命名空间context--&gt;</span><br><span class="line">&lt;!--    注解开发--&gt;</span><br><span class="line">&lt;!--    扫描组件配置--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;org.demo&quot;/&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;org.demo.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="line"><span class="comment">//交给容器管理</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 按名称获取bean</span></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>按名称注入不推荐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//不另命名</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> context.getBean(BookService.class);</span><br><span class="line"><span class="comment">//按类型获取bean</span></span><br><span class="line">        System.out.println(bookService);</span><br></pre></td></tr></table></figure><p><strong>不过表现层用@Controller，业务层@Service，数据层@Repository，只是便于区分，功能和component一样的</strong></p><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentSpan(&#123;&quot;org.demo&quot;,&quot;com.example&quot;&#125;)</span><span class="comment">//包扫描</span></span><br><span class="line"><span class="comment">//完全取代applicationContext.xml这个配置文件了</span></span><br></pre></td></tr></table></figure><h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;命名&quot;)</span><span class="comment">//这个是给一个接口有两个实现类时，选择其中一个命名来的</span></span><br></pre></td></tr></table></figure><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><p>在不惊动原始设计的基础上，为其增强功能的编程思想。 </p><p><img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20241114222040947.png" alt="image-20241114222040947"></p><p>将切入点和通知绑定的东西，<strong>叫做切面</strong>。</p><p>想要增强的共性功能，<strong>叫做通知</strong>。</p><p>通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//告诉扫描我是aop</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNotice</span> &#123;</span><br><span class="line">    <span class="comment">//定义切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void org.demo.dao.BookDao.delete())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义通知，并切面：绑定通知和切入点关系</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.demo&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//扫描切面的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5个切面类型</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//定义切入点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* org.demo.dao.BookDao.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义通知，并切面：绑定通知和切入点关系</span></span><br><span class="line">    <span class="comment">//1.前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around start&quot;</span>);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.后置通知（无论通知运行出不出错都执行</span></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.不出错后置执行</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.出错异常后执行</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如有多个MyAdvice可以通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来着控制切面类的执行顺序</p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&quot;execution(* org.demo.dao.BookDao.*(..))&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&quot;@annotation(包名.自定义注解)&quot;</span>)</span><br><span class="line"><span class="comment">//有该注解的方法生效</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="线性表构建树结构"><a href="#线性表构建树结构" class="headerlink" title="线性表构建树结构"></a>线性表构建树结构</h2><p>大家都由根延伸而出，且根是一个虚无的东西.</p><p>如一个树形目录：</p><p>Directory（目录表）</p><p>一级目录深度为1，二级目录深度为2….</p><table><thead><tr><th>id</th><th>parent_id</th><th>name</th><th>deep</th></tr></thead><tbody><tr><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>根（虚无，不显示）</strong></td><td>0</td></tr><tr><td>2</td><td>1</td><td>电子产品</td><td>1</td></tr><tr><td>3</td><td>1</td><td>家具</td><td>1</td></tr><tr><td>4</td><td>2</td><td>手机</td><td>2</td></tr><tr><td>5</td><td>3</td><td>沙发</td><td>2</td></tr></tbody></table><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="eg-用户注册"><a href="#eg-用户注册" class="headerlink" title="eg:用户注册"></a>eg:用户注册</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> RegisterUser(</span><br><span class="line">    <span class="keyword">IN</span> p_username <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">IN</span> p_email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">IN</span> p_password <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">OUT</span> p_result <span class="type">VARCHAR</span>(<span class="number">50</span>)  <span class="comment">-- 添加输出参数用于返回结果</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 声明变量用于存储插入的用户ID和检查结果</span></span><br><span class="line">    <span class="keyword">DECLARE</span> v_user_id <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> v_username_exists <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> v_email_exists <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 开始事务</span></span><br><span class="line">    <span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 检查用户名是否存在</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> v_username_exists <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> p_username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 检查邮箱是否存在</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> v_email_exists <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> p_email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果用户名或邮箱已存在，则设置结果为失败并回滚事务</span></span><br><span class="line">    IF v_username_exists <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">OR</span> v_email_exists <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">SET</span> p_result <span class="operator">=</span> <span class="string">&#x27;FAILURE&#x27;</span>;</span><br><span class="line">        <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="comment">-- 插入用户信息</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, email, password)</span><br><span class="line">        <span class="keyword">VALUES</span> (p_username, p_email, p_password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 获取插入的用户ID</span></span><br><span class="line">        <span class="keyword">SET</span> v_user_id <span class="operator">=</span> LAST_INSERT_ID();</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 提交事务</span></span><br><span class="line">        <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 设置结果为成功</span></span><br><span class="line">        <span class="keyword">SET</span> p_result <span class="operator">=</span> <span class="string">&#x27;SUCCESS&#x27;</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="后端接收："><a href="#后端接收：" class="headerlink" title="后端接收："></a>后端接收：</h4><p>在Spring Boot项目中结合MyBatis调用存储过程的方法如下：</p><p>创建一个Mapper接口，用于定义调用存储过程的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.yourapp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    String <span class="title function_">registerUser</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                        <span class="meta">@Param(&quot;email&quot;)</span> String email,</span></span><br><span class="line"><span class="params">                        <span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，创建一个XML映射文件（例如<code>UserMapper.xml</code>），放在<code>src/main/resources/mapper</code>目录下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.yourapp.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;registerUser&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;CALLABLE&quot;</span>&gt;</span></span><br><span class="line">        &#123;call RegisterUser(</span><br><span class="line">            #&#123;username, mode=IN, jdbcType=VARCHAR&#125;,</span><br><span class="line">            #&#123;email, mode=IN, jdbcType=VARCHAR&#125;,</span><br><span class="line">            #&#123;password, mode=IN, jdbcType=VARCHAR&#125;,</span><br><span class="line">            #&#123;result, mode=OUT, jdbcType=VARCHAR&#125;</span><br><span class="line">        )&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，当你发送一个POST请求到<code>/register</code>端点时，Spring Boot将调用存储过程<code>RegisterUser</code>来执行用户注册操作，并返回结果。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>避免使用物理删除，用户删除时，数据还是要保留，用is_delete保存是否删除。（逻辑删除）</p><p>在树形数据库表中，删除的时候需要判断孩子节点，所以需要创建<strong>存储过程</strong>。</p><h2 id="一些AI回答的问题"><a href="#一些AI回答的问题" class="headerlink" title="一些AI回答的问题"></a>一些AI回答的问题</h2><h3 id="PROCEDURE（存储过程）和FUNCTION（函数）"><a href="#PROCEDURE（存储过程）和FUNCTION（函数）" class="headerlink" title="PROCEDURE（存储过程）和FUNCTION（函数）"></a><code>PROCEDURE</code>（存储过程）和<code>FUNCTION</code>（函数）</h3><p>SQL中的<code>PROCEDURE</code>（存储过程）和<code>FUNCTION</code>（函数）都是预编译的SQL代码块，它们可以在数据库中存储并重复使用。尽管它们在某些方面相似，但它们之间存在一些关键区别：</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li><p><strong>返回值</strong>：</p><ul><li><strong>PROCEDURE</strong>：可以有输出参数，但不直接返回值。</li><li><strong>FUNCTION</strong>：必须返回一个值。</li></ul></li><li><p><strong>调用方式</strong>：</p><ul><li><strong>PROCEDURE</strong>：通常通过<code>CALL</code>语句调用。</li><li><strong>FUNCTION</strong>：可以作为表达式的一部分在SQL查询中使用。</li></ul></li><li><p><strong>事务控制</strong>：</p><ul><li><strong>PROCEDURE</strong>：可以包含事务控制语句（如<code>COMMIT</code>和<code>ROLLBACK</code>）。</li><li><strong>FUNCTION</strong>：通常不允许包含事务控制语句。</li></ul></li><li><p><strong>副作用</strong>：</p><ul><li><strong>PROCEDURE</strong>：可以有副作用，如修改表数据。</li><li><strong>FUNCTION</strong>：通常不应该有副作用，应该保持幂等性。</li></ul></li></ol><h4 id="用户注册逻辑的选择"><a href="#用户注册逻辑的选择" class="headerlink" title="用户注册逻辑的选择"></a>用户注册逻辑的选择</h4><p>对于用户注册的逻辑，通常更适合使用<code>PROCEDURE</code>，因为：</p><ul><li>注册过程可能涉及多个步骤（如插入用户信息、发送验证邮件等），这些步骤可以通过存储过程的逻辑来实现。</li><li>注册过程可能需要有副作用（如修改表数据）。</li><li>注册过程可能需要事务控制以确保数据的一致性。</li></ul><h4 id="示例：用户注册的存储过程"><a href="#示例：用户注册的存储过程" class="headerlink" title="示例：用户注册的存储过程"></a>示例：用户注册的存储过程</h4><p>以下是一个简单的用户注册存储过程的示例，假设我们有一个名为<code>users</code>的表，结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>存储过程如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> RegisterUser(</span><br><span class="line">    <span class="keyword">IN</span> p_username <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">IN</span> p_email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">IN</span> p_password <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 声明变量用于存储插入的用户ID</span></span><br><span class="line">    <span class="keyword">DECLARE</span> v_user_id <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 开始事务</span></span><br><span class="line">    <span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 插入用户信息</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, email, password)</span><br><span class="line">    <span class="keyword">VALUES</span> (p_username, p_email, p_password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 获取插入的用户ID</span></span><br><span class="line">    <span class="keyword">SET</span> v_user_id <span class="operator">=</span> LAST_INSERT_ID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 提交事务</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 输出用户ID（可选）</span></span><br><span class="line">    <span class="keyword">SELECT</span> v_user_id <span class="keyword">AS</span> user_id;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> RegisterUser(<span class="string">&#x27;john_doe&#x27;</span>, <span class="string">&#x27;john@example.com&#x27;</span>, <span class="string">&#x27;hashed_password&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol><li><strong>参数</strong>：存储过程<code>RegisterUser</code>接受三个输入参数：<code>username</code>、<code>email</code>和<code>password</code>。</li><li><strong>事务控制</strong>：使用<code>START TRANSACTION</code>和<code>COMMIT</code>确保插入操作的原子性。</li><li><strong>插入操作</strong>：将用户信息插入到<code>users</code>表中。</li><li><strong>获取插入的用户ID</strong>：使用<code>LAST_INSERT_ID()</code>获取插入的用户ID，并将其存储在变量<code>v_user_id</code>中。</li><li><strong>输出用户ID</strong>：可以选择性地输出插入的用户ID。</li></ol><p>通过这种方式，用户注册的逻辑可以封装在一个存储过程中，便于管理和复用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到第五次元</title>
      <link href="/2018/01/05/hello-world/"/>
      <url>/2018/01/05/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="欢迎来到第五次元"><a href="#欢迎来到第五次元" class="headerlink" title="欢迎来到第五次元"></a>欢迎来到第五次元</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
